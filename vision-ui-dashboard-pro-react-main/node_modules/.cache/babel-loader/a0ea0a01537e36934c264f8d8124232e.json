{"ast":null,"code":"import { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id); // $FlowFixMe\n\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu, key) {\n  const result = Buffer.alloc(apdu.length);\n\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n\n  return result;\n} // Convert from normal to web-safe, strip trailing \"=\"s\n\n\nconst webSafe64 = base64 => base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\"); // Convert from web-safe to normal, add trailing \"=\"s\n\n\nconst normal64 = base64 => base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n\nfunction attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(response => {\n    const {\n      signatureData\n    } = response;\n\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(t => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\n\n\nexport default class TransportU2F extends Transport {\n  /*\n   */\n\n  /*\n   */\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_) {\n    let _openTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    this.scrambleKey = void 0;\n    this.unwrap = true;\n    transportInstances.push(this);\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  async exchange(apdu) {\n    try {\n      return await attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        } // the wrapping make error more usable and \"printable\" to the end user.\n\n\n        throw wrapU2FTransportError(e, \"Failed to sign with Ledger device: U2F \" + e.metaData.type, \"U2F_\" + e.metaData.code);\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   */\n\n\n  setScrambleKey(scrambleKey) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n  /**\n   */\n\n\n  setUnwrap(unwrap) {\n    this.unwrap = unwrap;\n  }\n\n  close() {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n\n}\nTransportU2F.isSupported = isSupported;\n\nTransportU2F.list = () => // this transport is not discoverable but we are going to guess if it is here with isSupported()\nisSupported().then(supported => supported ? [null] : []);\n\nTransportU2F.listen = observer => {\n  let unsubscribed = false;\n  isSupported().then(supported => {\n    if (unsubscribed) return;\n\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: () => {\n      unsubscribed = true;\n    }\n  };\n};","map":{"version":3,"sources":["../src/TransportU2F.js"],"names":["err","result","Buffer","apdu","i","key","webSafe64","base64","normal64","keyHandle","wrapApdu","challenge","signRequest","version","appId","location","origin","log","timeoutMillis","response","signatureData","data","transportInstances","t","u2fError","TransportU2F","isSupported","list","supported","listen","observer","unsubscribed","type","descriptor","unsubscribe","scrambleKey","unwrap","open","_openTimeout","constructor","exchange","attemptExchange","isU2FError","e","isTimeoutU2FError","emitDisconnect","wrapU2FTransportError","setScrambleKey","setUnwrap","close","Promise"],"mappings":"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","sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin,\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then((response) => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach((t) => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then((supported) => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then((supported) => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      },\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}