{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NumericalBinaryCodec = void 0;\n\nvar typesystem_1 = require(\"../typesystem\");\n\nvar utils_1 = require(\"./utils\");\n\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\n\n\nvar NumericalBinaryCodec = /*#__PURE__*/function () {\n  function NumericalBinaryCodec() {\n    _classCallCheck(this, NumericalBinaryCodec);\n  }\n\n  _createClass(NumericalBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var offset = 0;\n      var length = type.sizeInBytes;\n\n      if (!length) {\n        // Size of type is not known: arbitrary-size big integer.\n        // Therefore, we must read the length from the header.\n        offset = constants_1.SizeOfU32;\n        length = buffer.readUInt32BE(0);\n      }\n\n      var payload = buffer.slice(offset, offset + length);\n      var result = this.decodeTopLevel(payload, type);\n      var decodedLength = length + offset;\n      return [result, decodedLength];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var payload = utils_1.cloneBuffer(buffer);\n      var empty = buffer.length == 0;\n\n      if (empty) {\n        return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n      }\n\n      var isPositive = !type.withSign || utils_1.isMsbZero(payload);\n\n      if (isPositive) {\n        var _value = utils_1.bufferToBigInt(payload);\n\n        return new typesystem_1.NumericalValue(type, _value);\n      } // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n\n\n      utils_1.flipBufferBitsInPlace(payload);\n      var value = utils_1.bufferToBigInt(payload);\n      var negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n      var negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n      return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(primitive) {\n      if (primitive.sizeInBytes) {\n        return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n      } // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n\n\n      var buffer = this.encodeTopLevel(primitive);\n      var length = Buffer.alloc(constants_1.SizeOfU32);\n      length.writeUInt32BE(buffer.length);\n      return Buffer.concat([length, buffer]);\n    }\n  }, {\n    key: \"encodeNestedFixedSize\",\n    value: function encodeNestedFixedSize(primitive, size) {\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(size, 0x00);\n      }\n\n      if (!primitive.withSign) {\n        var _buffer = utils_1.bigIntToBuffer(primitive.value);\n\n        var _paddingBytes = Buffer.alloc(size - _buffer.length, 0x00);\n\n        return Buffer.concat([_paddingBytes, _buffer]);\n      }\n\n      if (primitive.value.isPositive()) {\n        var _buffer2 = utils_1.bigIntToBuffer(primitive.value); // Fix ambiguity if any\n\n\n        if (utils_1.isMsbOne(_buffer2)) {\n          _buffer2 = utils_1.prependByteToBuffer(_buffer2, 0x00);\n        }\n\n        var _paddingBytes2 = Buffer.alloc(size - _buffer2.length, 0x00);\n\n        return Buffer.concat([_paddingBytes2, _buffer2]);\n      } // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n\n\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer); // Fix ambiguity if any\n\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n\n      var paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n      return Buffer.concat([paddingBytes, buffer]);\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(primitive) {\n      var withSign = primitive.withSign; // Nothing or Zero:\n\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(0);\n      } // I don't care about the sign:\n\n\n      if (!withSign) {\n        return utils_1.bigIntToBuffer(primitive.value);\n      }\n\n      return this.encodePrimitive(primitive);\n    }\n  }, {\n    key: \"encodePrimitive\",\n    value: function encodePrimitive(primitive) {\n      // Positive:\n      if (primitive.value.isPositive()) {\n        var _buffer3 = utils_1.bigIntToBuffer(primitive.value); // Fix ambiguity if any\n\n\n        if (utils_1.isMsbOne(_buffer3)) {\n          _buffer3 = utils_1.prependByteToBuffer(_buffer3, 0x00);\n        }\n\n        return _buffer3;\n      } // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n\n\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer); // Fix ambiguity if any\n\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n\n      return buffer;\n    }\n  }]);\n\n  return NumericalBinaryCodec;\n}();\n\nexports.NumericalBinaryCodec = NumericalBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/numerical.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NumericalBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"./utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nclass NumericalBinaryCodec {\n    decodeNested(buffer, type) {\n        let offset = 0;\n        let length = type.sizeInBytes;\n        if (!length) {\n            // Size of type is not known: arbitrary-size big integer.\n            // Therefore, we must read the length from the header.\n            offset = constants_1.SizeOfU32;\n            length = buffer.readUInt32BE(0);\n        }\n        let payload = buffer.slice(offset, offset + length);\n        let result = this.decodeTopLevel(payload, type);\n        let decodedLength = length + offset;\n        return [result, decodedLength];\n    }\n    decodeTopLevel(buffer, type) {\n        let payload = utils_1.cloneBuffer(buffer);\n        let empty = buffer.length == 0;\n        if (empty) {\n            return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n        }\n        let isPositive = !type.withSign || utils_1.isMsbZero(payload);\n        if (isPositive) {\n            let value = utils_1.bufferToBigInt(payload);\n            return new typesystem_1.NumericalValue(type, value);\n        }\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n        utils_1.flipBufferBitsInPlace(payload);\n        let value = utils_1.bufferToBigInt(payload);\n        let negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n        let negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n        return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n    encodeNested(primitive) {\n        if (primitive.sizeInBytes) {\n            return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n        }\n        // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n        let buffer = this.encodeTopLevel(primitive);\n        let length = Buffer.alloc(constants_1.SizeOfU32);\n        length.writeUInt32BE(buffer.length);\n        return Buffer.concat([length, buffer]);\n    }\n    encodeNestedFixedSize(primitive, size) {\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(size, 0x00);\n        }\n        if (!primitive.withSign) {\n            const buffer = utils_1.bigIntToBuffer(primitive.value);\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        const paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n        return Buffer.concat([paddingBytes, buffer]);\n    }\n    encodeTopLevel(primitive) {\n        let withSign = primitive.withSign;\n        // Nothing or Zero:\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(0);\n        }\n        // I don't care about the sign:\n        if (!withSign) {\n            return utils_1.bigIntToBuffer(primitive.value);\n        }\n        return this.encodePrimitive(primitive);\n    }\n    encodePrimitive(primitive) {\n        // Positive:\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            return buffer;\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        return buffer;\n    }\n}\nexports.NumericalBinaryCodec = NumericalBinaryCodec;\n//# sourceMappingURL=numerical.js.map"]},"metadata":{},"sourceType":"script"}