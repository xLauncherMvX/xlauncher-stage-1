{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _construct = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/construct.js\").default;\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeMapper = void 0;\n\nvar errors = __importStar(require(\"../../errors\"));\n\nvar address_1 = require(\"./address\");\n\nvar boolean_1 = require(\"./boolean\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar composite_1 = require(\"./composite\");\n\nvar enum_1 = require(\"./enum\");\n\nvar generic_1 = require(\"./generic\");\n\nvar h256_1 = require(\"./h256\");\n\nvar numerical_1 = require(\"./numerical\");\n\nvar struct_1 = require(\"./struct\");\n\nvar fields_1 = require(\"./fields\");\n\nvar tokenIdentifier_1 = require(\"./tokenIdentifier\");\n\nvar variadic_1 = require(\"./variadic\");\n\nvar algebraic_1 = require(\"./algebraic\");\n\nvar genericArray_1 = require(\"./genericArray\");\n\nvar string_1 = require(\"./string\");\n\nvar tuple_1 = require(\"./tuple\");\n\nvar codeMetadata_1 = require(\"./codeMetadata\");\n\nvar nothing_1 = require(\"./nothing\");\n\nvar TypeMapper = /*#__PURE__*/function () {\n  function TypeMapper() {\n    var customTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, TypeMapper);\n\n    this.openTypesFactories = new Map([[\"Option\", function () {\n      return new generic_1.OptionType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"List\", function () {\n      return new generic_1.ListType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n    [\"VarArgs\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"MultiResultVec\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"variadic\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalArg\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"optional\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalResult\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"multi\", function () {\n      for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n        typeParameters[_key] = arguments[_key];\n      }\n\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"MultiArg\", function () {\n      for (var _len2 = arguments.length, typeParameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeParameters[_key2] = arguments[_key2];\n      }\n\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"MultiResult\", function () {\n      for (var _len3 = arguments.length, typeParameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeParameters[_key3] = arguments[_key3];\n      }\n\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"multi\", function () {\n      for (var _len4 = arguments.length, typeParameters = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeParameters[_key4] = arguments[_key4];\n      }\n\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n    [\"tuple\", function () {\n      for (var _len5 = arguments.length, typeParameters = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeParameters[_key5] = arguments[_key5];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple2\", function () {\n      for (var _len6 = arguments.length, typeParameters = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeParameters[_key6] = arguments[_key6];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple3\", function () {\n      for (var _len7 = arguments.length, typeParameters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        typeParameters[_key7] = arguments[_key7];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple4\", function () {\n      for (var _len8 = arguments.length, typeParameters = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        typeParameters[_key8] = arguments[_key8];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple5\", function () {\n      for (var _len9 = arguments.length, typeParameters = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        typeParameters[_key9] = arguments[_key9];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple6\", function () {\n      for (var _len10 = arguments.length, typeParameters = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        typeParameters[_key10] = arguments[_key10];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple7\", function () {\n      for (var _len11 = arguments.length, typeParameters = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        typeParameters[_key11] = arguments[_key11];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple8\", function () {\n      for (var _len12 = arguments.length, typeParameters = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        typeParameters[_key12] = arguments[_key12];\n      }\n\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], // Known-length arrays.\n    // TODO: Handle these in typeExpressionParser, perhaps?\n    [\"array20\", function () {\n      return new genericArray_1.ArrayVecType(20, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array32\", function () {\n      return new genericArray_1.ArrayVecType(32, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array64\", function () {\n      return new genericArray_1.ArrayVecType(64, arguments.length <= 0 ? undefined : arguments[0]);\n    }]]); // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).\n\n    this.closedTypesMap = new Map([[\"u8\", new numerical_1.U8Type()], [\"u16\", new numerical_1.U16Type()], [\"u32\", new numerical_1.U32Type()], [\"u64\", new numerical_1.U64Type()], [\"U64\", new numerical_1.U64Type()], [\"BigUint\", new numerical_1.BigUIntType()], [\"i8\", new numerical_1.I8Type()], [\"i16\", new numerical_1.I16Type()], [\"i32\", new numerical_1.I32Type()], [\"i64\", new numerical_1.I64Type()], [\"Bigint\", new numerical_1.BigIntType()], [\"BigInt\", new numerical_1.BigIntType()], [\"bool\", new boolean_1.BooleanType()], [\"bytes\", new bytes_1.BytesType()], [\"Address\", new address_1.AddressType()], [\"H256\", new h256_1.H256Type()], [\"utf-8 string\", new string_1.StringType()], [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()], [\"CodeMetadata\", new codeMetadata_1.CodeMetadataType()], [\"nothing\", new nothing_1.NothingType()], [\"AsyncCall\", new nothing_1.NothingType()]]);\n\n    var _iterator = _createForOfIteratorHelper(customTypes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var customType = _step.value;\n        this.closedTypesMap.set(customType.getName(), customType);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  _createClass(TypeMapper, [{\n    key: \"mapRecursiveType\",\n    value: function mapRecursiveType(type) {\n      var isGeneric = type.isGenericType();\n\n      if (type instanceof enum_1.EnumType) {\n        // This will call mapType() recursively, for all the enum variant fields.\n        return this.mapEnumType(type);\n      }\n\n      if (type instanceof struct_1.StructType) {\n        // This will call mapType() recursively, for all the struct's fields.\n        return this.mapStructType(type);\n      }\n\n      if (isGeneric) {\n        // This will call mapType() recursively, for all the type parameters.\n        return this.mapGenericType(type);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"mapType\",\n    value: function mapType(type) {\n      var _a;\n\n      var mappedType = this.mapRecursiveType(type);\n\n      if (mappedType !== null) {\n        return mappedType;\n      }\n\n      var knownClosedType = this.closedTypesMap.get(type.getName());\n\n      if (!knownClosedType) {\n        throw new errors.ErrTypingSystem(\"Cannot map the type \\\"\".concat(type.getName(), \"\\\" to a known type\"));\n      }\n\n      return (_a = this.mapRecursiveType(knownClosedType)) !== null && _a !== void 0 ? _a : knownClosedType;\n    }\n  }, {\n    key: \"feedCustomType\",\n    value: function feedCustomType(type) {\n      this.closedTypesMap.delete(type.getName());\n      this.closedTypesMap.set(type.getName(), type);\n    }\n  }, {\n    key: \"mapStructType\",\n    value: function mapStructType(type) {\n      var mappedFields = this.mappedFields(type.getFieldsDefinitions());\n      var mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n      return mappedStruct;\n    }\n  }, {\n    key: \"mapEnumType\",\n    value: function mapEnumType(type) {\n      var _this = this;\n\n      var variants = type.variants.map(function (variant) {\n        return new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, _this.mappedFields(variant.getFieldsDefinitions()));\n      });\n      var mappedEnum = new enum_1.EnumType(type.getName(), variants);\n      return mappedEnum;\n    }\n  }, {\n    key: \"mappedFields\",\n    value: function mappedFields(definitions) {\n      var _this2 = this;\n\n      return definitions.map(function (definition) {\n        return new fields_1.FieldDefinition(definition.name, definition.description, _this2.mapType(definition.type));\n      });\n    }\n  }, {\n    key: \"mapGenericType\",\n    value: function mapGenericType(type) {\n      var _this3 = this;\n\n      var typeParameters = type.getTypeParameters();\n      var mappedTypeParameters = typeParameters.map(function (item) {\n        return _this3.mapType(item);\n      });\n      var factory = this.openTypesFactories.get(type.getName());\n\n      if (!factory) {\n        throw new errors.ErrTypingSystem(\"Cannot map the generic type \\\"\".concat(type.getName(), \"\\\" to a known type\"));\n      }\n\n      return factory.apply(void 0, _toConsumableArray(mappedTypeParameters));\n    }\n  }]);\n\n  return TypeMapper;\n}();\n\nexports.TypeMapper = TypeMapper;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/typeMapper.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAYA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;IAIa,U;EAIT,sBAA0C;IAAA,IAA9B,WAA8B,uEAAF,EAAE;;IAAA;;IACtC,KAAK,kBAAL,GAA0B,IAAI,GAAJ,CAA6B,CACnD,CAAC,QAAD,EAAW;MAAA,OAA+B,IAAI,SAAA,CAAA,UAAJ,kDAA/B;IAAA,CAAX,CADmD,EAEnD,CAAC,MAAD,EAAS;MAAA,OAA+B,IAAI,SAAA,CAAA,QAAJ,kDAA/B;IAAA,CAAT,CAFmD,EAGnD;IACA,CAAC,SAAD,EAAY;MAAA,OAA+B,IAAI,UAAA,CAAA,YAAJ,kDAA/B;IAAA,CAAZ,CAJmD,EAKnD,CAAC,gBAAD,EAAmB;MAAA,OAA+B,IAAI,UAAA,CAAA,YAAJ,kDAA/B;IAAA,CAAnB,CALmD,EAMnD,CAAC,UAAD,EAAa;MAAA,OAA+B,IAAI,UAAA,CAAA,YAAJ,kDAA/B;IAAA,CAAb,CANmD,EAOnD,CAAC,aAAD,EAAgB;MAAA,OAA+B,IAAI,WAAA,CAAA,YAAJ,kDAA/B;IAAA,CAAhB,CAPmD,EAQnD,CAAC,UAAD,EAAa;MAAA,OAA+B,IAAI,WAAA,CAAA,YAAJ,kDAA/B;IAAA,CAAb,CARmD,EASnD,CAAC,gBAAD,EAAmB;MAAA,OAA+B,IAAI,WAAA,CAAA,YAAJ,kDAA/B;IAAA,CAAnB,CATmD,EAUnD,CAAC,OAAD,EAAU;MAAA,kCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,WAAA,CAAA,aAAnC,EAAoD,cAApD;IAAA,CAAV,CAVmD,EAWnD,CAAC,UAAD,EAAa;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,WAAA,CAAA,aAAnC,EAAoD,cAApD;IAAA,CAAb,CAXmD,EAYnD,CAAC,aAAD,EAAgB;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,WAAA,CAAA,aAAnC,EAAoD,cAApD;IAAA,CAAhB,CAZmD,EAanD,CAAC,OAAD,EAAU;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,WAAA,CAAA,aAAnC,EAAoD,cAApD;IAAA,CAAV,CAbmD,EAcnD;IACA,CAAC,OAAD,EAAU;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAV,CAfmD,EAgBnD,CAAC,QAAD,EAAW;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CAhBmD,EAiBnD,CAAC,QAAD,EAAW;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CAjBmD,EAkBnD,CAAC,QAAD,EAAW;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CAlBmD,EAmBnD,CAAC,QAAD,EAAW;MAAA,mCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CAnBmD,EAoBnD,CAAC,QAAD,EAAW;MAAA,oCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CApBmD,EAqBnD,CAAC,QAAD,EAAW;MAAA,oCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CArBmD,EAsBnD,CAAC,QAAD,EAAW;MAAA,oCAAI,cAAJ;QAAI,cAAJ;MAAA;;MAAA,kBAAmC,OAAA,CAAA,SAAnC,EAAgD,cAAhD;IAAA,CAAX,CAtBmD,EAuBnD;IACA;IACA,CAAC,SAAD,EAAY;MAAA,OAA+B,IAAI,cAAA,CAAA,YAAJ,CAAiB,EAAjB,mDAA/B;IAAA,CAAZ,CAzBmD,EA0BnD,CAAC,SAAD,EAAY;MAAA,OAA+B,IAAI,cAAA,CAAA,YAAJ,CAAiB,EAAjB,mDAA/B;IAAA,CAAZ,CA1BmD,EA2BnD,CAAC,SAAD,EAAY;MAAA,OAA+B,IAAI,cAAA,CAAA,YAAJ,CAAiB,EAAjB,mDAA/B;IAAA,CAAZ,CA3BmD,CAA7B,CAA1B,CADsC,CA+BtC;;IACA,KAAK,cAAL,GAAsB,IAAI,GAAJ,CAAsB,CACxC,CAAC,IAAD,EAAO,IAAI,WAAA,CAAA,MAAJ,EAAP,CADwC,EAExC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CAFwC,EAGxC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CAHwC,EAIxC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CAJwC,EAKxC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CALwC,EAMxC,CAAC,SAAD,EAAY,IAAI,WAAA,CAAA,WAAJ,EAAZ,CANwC,EAOxC,CAAC,IAAD,EAAO,IAAI,WAAA,CAAA,MAAJ,EAAP,CAPwC,EAQxC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CARwC,EASxC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CATwC,EAUxC,CAAC,KAAD,EAAQ,IAAI,WAAA,CAAA,OAAJ,EAAR,CAVwC,EAWxC,CAAC,QAAD,EAAW,IAAI,WAAA,CAAA,UAAJ,EAAX,CAXwC,EAYxC,CAAC,QAAD,EAAW,IAAI,WAAA,CAAA,UAAJ,EAAX,CAZwC,EAaxC,CAAC,MAAD,EAAS,IAAI,SAAA,CAAA,WAAJ,EAAT,CAbwC,EAcxC,CAAC,OAAD,EAAU,IAAI,OAAA,CAAA,SAAJ,EAAV,CAdwC,EAexC,CAAC,SAAD,EAAY,IAAI,SAAA,CAAA,WAAJ,EAAZ,CAfwC,EAgBxC,CAAC,MAAD,EAAS,IAAI,MAAA,CAAA,QAAJ,EAAT,CAhBwC,EAiBxC,CAAC,cAAD,EAAiB,IAAI,QAAA,CAAA,UAAJ,EAAjB,CAjBwC,EAkBxC,CAAC,iBAAD,EAAoB,IAAI,iBAAA,CAAA,mBAAJ,EAApB,CAlBwC,EAmBxC,CAAC,cAAD,EAAiB,IAAI,cAAA,CAAA,gBAAJ,EAAjB,CAnBwC,EAoBxC,CAAC,SAAD,EAAY,IAAI,SAAA,CAAA,WAAJ,EAAZ,CApBwC,EAqBxC,CAAC,WAAD,EAAc,IAAI,SAAA,CAAA,WAAJ,EAAd,CArBwC,CAAtB,CAAtB;;IAhCsC,2CAwDb,WAxDa;IAAA;;IAAA;MAwDtC,oDAAsC;QAAA,IAA3B,UAA2B;QAClC,KAAK,cAAL,CAAoB,GAApB,CAAwB,UAAU,CAAC,OAAX,EAAxB,EAA8C,UAA9C;MACH;IA1DqC;MAAA;IAAA;MAAA;IAAA;EA2DzC;;;;WAED,0BAAiB,IAAjB,EAA2B;MACvB,IAAI,SAAS,GAAG,IAAI,CAAC,aAAL,EAAhB;;MAEA,IAAI,IAAI,YAAY,MAAA,CAAA,QAApB,EAA8B;QAC1B;QACA,OAAO,KAAK,WAAL,CAAiB,IAAjB,CAAP;MACH;;MAED,IAAI,IAAI,YAAY,QAAA,CAAA,UAApB,EAAgC;QAC5B;QACA,OAAO,KAAK,aAAL,CAAmB,IAAnB,CAAP;MACH;;MAED,IAAI,SAAJ,EAAe;QACX;QACA,OAAO,KAAK,cAAL,CAAoB,IAApB,CAAP;MACH;;MACD,OAAO,IAAP;IACH;;;WAED,iBAAQ,IAAR,EAAkB;;;MACd,IAAI,UAAU,GAAG,KAAK,gBAAL,CAAsB,IAAtB,CAAjB;;MACA,IAAI,UAAU,KAAK,IAAnB,EAAyB;QACrB,OAAO,UAAP;MACH;;MAED,IAAI,eAAe,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAwB,IAAI,CAAC,OAAL,EAAxB,CAAtB;;MACA,IAAI,CAAC,eAAL,EAAsB;QAClB,MAAM,IAAI,MAAM,CAAC,eAAX,iCAAmD,IAAI,CAAC,OAAL,EAAnD,wBAAN;MACH;;MAED,OAAA,CAAA,EAAA,GAAO,KAAK,gBAAL,CAAsB,eAAtB,CAAP,MAA6C,IAA7C,IAA6C,EAAA,KAAA,KAAA,CAA7C,GAA6C,EAA7C,GAAiD,eAAjD;IACH;;;WAED,wBAAe,IAAf,EAAyB;MACrB,KAAK,cAAL,CAAoB,MAApB,CAA2B,IAAI,CAAC,OAAL,EAA3B;MACA,KAAK,cAAL,CAAoB,GAApB,CAAwB,IAAI,CAAC,OAAL,EAAxB,EAAwC,IAAxC;IACH;;;WAEO,uBAAc,IAAd,EAA8B;MAClC,IAAI,YAAY,GAAG,KAAK,YAAL,CAAkB,IAAI,CAAC,oBAAL,EAAlB,CAAnB;MACA,IAAI,YAAY,GAAG,IAAI,QAAA,CAAA,UAAJ,CAAe,IAAI,CAAC,OAAL,EAAf,EAA+B,YAA/B,CAAnB;MACA,OAAO,YAAP;IACH;;;WAEO,qBAAY,IAAZ,EAA0B;MAAA;;MAC9B,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAL,CAAc,GAAd,CACX,UAAC,OAAD;QAAA,OACI,IAAI,MAAA,CAAA,qBAAJ,CACI,OAAO,CAAC,IADZ,EAEI,OAAO,CAAC,YAFZ,EAGI,KAAI,CAAC,YAAL,CAAkB,OAAO,CAAC,oBAAR,EAAlB,CAHJ,CADJ;MAAA,CADW,CAAf;MAQA,IAAI,UAAU,GAAG,IAAI,MAAA,CAAA,QAAJ,CAAa,IAAI,CAAC,OAAL,EAAb,EAA6B,QAA7B,CAAjB;MACA,OAAO,UAAP;IACH;;;WAEO,sBAAa,WAAb,EAA2C;MAAA;;MAC/C,OAAO,WAAW,CAAC,GAAZ,CACH,UAAC,UAAD;QAAA,OAAgB,IAAI,QAAA,CAAA,eAAJ,CAAoB,UAAU,CAAC,IAA/B,EAAqC,UAAU,CAAC,WAAhD,EAA6D,MAAI,CAAC,OAAL,CAAa,UAAU,CAAC,IAAxB,CAA7D,CAAhB;MAAA,CADG,CAAP;IAGH;;;WAEO,wBAAe,IAAf,EAAyB;MAAA;;MAC7B,IAAI,cAAc,GAAG,IAAI,CAAC,iBAAL,EAArB;MACA,IAAI,oBAAoB,GAAG,cAAc,CAAC,GAAf,CAAmB,UAAC,IAAD;QAAA,OAAU,MAAI,CAAC,OAAL,CAAa,IAAb,CAAV;MAAA,CAAnB,CAA3B;MAEA,IAAI,OAAO,GAAG,KAAK,kBAAL,CAAwB,GAAxB,CAA4B,IAAI,CAAC,OAAL,EAA5B,CAAd;;MACA,IAAI,CAAC,OAAL,EAAc;QACV,MAAM,IAAI,MAAM,CAAC,eAAX,yCAA2D,IAAI,CAAC,OAAL,EAA3D,wBAAN;MACH;;MAED,OAAO,OAAO,MAAP,4BAAW,oBAAX,EAAP;IACH;;;;;;AA3IL,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeMapper = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst address_1 = require(\"./address\");\nconst boolean_1 = require(\"./boolean\");\nconst bytes_1 = require(\"./bytes\");\nconst composite_1 = require(\"./composite\");\nconst enum_1 = require(\"./enum\");\nconst generic_1 = require(\"./generic\");\nconst h256_1 = require(\"./h256\");\nconst numerical_1 = require(\"./numerical\");\nconst struct_1 = require(\"./struct\");\nconst fields_1 = require(\"./fields\");\nconst tokenIdentifier_1 = require(\"./tokenIdentifier\");\nconst variadic_1 = require(\"./variadic\");\nconst algebraic_1 = require(\"./algebraic\");\nconst genericArray_1 = require(\"./genericArray\");\nconst string_1 = require(\"./string\");\nconst tuple_1 = require(\"./tuple\");\nconst codeMetadata_1 = require(\"./codeMetadata\");\nconst nothing_1 = require(\"./nothing\");\nclass TypeMapper {\n    constructor(customTypes = []) {\n        this.openTypesFactories = new Map([\n            [\"Option\", (...typeParameters) => new generic_1.OptionType(typeParameters[0])],\n            [\"List\", (...typeParameters) => new generic_1.ListType(typeParameters[0])],\n            // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n            [\"VarArgs\", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],\n            [\"MultiResultVec\", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],\n            [\"variadic\", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],\n            [\"OptionalArg\", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],\n            [\"optional\", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],\n            [\"OptionalResult\", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],\n            [\"multi\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            [\"MultiArg\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            [\"MultiResult\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            [\"multi\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n            [\"tuple\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple2\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple3\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple4\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple5\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple6\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple7\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple8\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            // Known-length arrays.\n            // TODO: Handle these in typeExpressionParser, perhaps?\n            [\"array20\", (...typeParameters) => new genericArray_1.ArrayVecType(20, typeParameters[0])],\n            [\"array32\", (...typeParameters) => new genericArray_1.ArrayVecType(32, typeParameters[0])],\n            [\"array64\", (...typeParameters) => new genericArray_1.ArrayVecType(64, typeParameters[0])],\n        ]);\n        // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).\n        this.closedTypesMap = new Map([\n            [\"u8\", new numerical_1.U8Type()],\n            [\"u16\", new numerical_1.U16Type()],\n            [\"u32\", new numerical_1.U32Type()],\n            [\"u64\", new numerical_1.U64Type()],\n            [\"U64\", new numerical_1.U64Type()],\n            [\"BigUint\", new numerical_1.BigUIntType()],\n            [\"i8\", new numerical_1.I8Type()],\n            [\"i16\", new numerical_1.I16Type()],\n            [\"i32\", new numerical_1.I32Type()],\n            [\"i64\", new numerical_1.I64Type()],\n            [\"Bigint\", new numerical_1.BigIntType()],\n            [\"BigInt\", new numerical_1.BigIntType()],\n            [\"bool\", new boolean_1.BooleanType()],\n            [\"bytes\", new bytes_1.BytesType()],\n            [\"Address\", new address_1.AddressType()],\n            [\"H256\", new h256_1.H256Type()],\n            [\"utf-8 string\", new string_1.StringType()],\n            [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()],\n            [\"CodeMetadata\", new codeMetadata_1.CodeMetadataType()],\n            [\"nothing\", new nothing_1.NothingType()],\n            [\"AsyncCall\", new nothing_1.NothingType()]\n        ]);\n        for (const customType of customTypes) {\n            this.closedTypesMap.set(customType.getName(), customType);\n        }\n    }\n    mapRecursiveType(type) {\n        let isGeneric = type.isGenericType();\n        if (type instanceof enum_1.EnumType) {\n            // This will call mapType() recursively, for all the enum variant fields.\n            return this.mapEnumType(type);\n        }\n        if (type instanceof struct_1.StructType) {\n            // This will call mapType() recursively, for all the struct's fields.\n            return this.mapStructType(type);\n        }\n        if (isGeneric) {\n            // This will call mapType() recursively, for all the type parameters.\n            return this.mapGenericType(type);\n        }\n        return null;\n    }\n    mapType(type) {\n        var _a;\n        let mappedType = this.mapRecursiveType(type);\n        if (mappedType !== null) {\n            return mappedType;\n        }\n        let knownClosedType = this.closedTypesMap.get(type.getName());\n        if (!knownClosedType) {\n            throw new errors.ErrTypingSystem(`Cannot map the type \"${type.getName()}\" to a known type`);\n        }\n        return (_a = this.mapRecursiveType(knownClosedType)) !== null && _a !== void 0 ? _a : knownClosedType;\n    }\n    feedCustomType(type) {\n        this.closedTypesMap.delete(type.getName());\n        this.closedTypesMap.set(type.getName(), type);\n    }\n    mapStructType(type) {\n        let mappedFields = this.mappedFields(type.getFieldsDefinitions());\n        let mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n        return mappedStruct;\n    }\n    mapEnumType(type) {\n        let variants = type.variants.map((variant) => new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, this.mappedFields(variant.getFieldsDefinitions())));\n        let mappedEnum = new enum_1.EnumType(type.getName(), variants);\n        return mappedEnum;\n    }\n    mappedFields(definitions) {\n        return definitions.map((definition) => new fields_1.FieldDefinition(definition.name, definition.description, this.mapType(definition.type)));\n    }\n    mapGenericType(type) {\n        let typeParameters = type.getTypeParameters();\n        let mappedTypeParameters = typeParameters.map((item) => this.mapType(item));\n        let factory = this.openTypesFactories.get(type.getName());\n        if (!factory) {\n            throw new errors.ErrTypingSystem(`Cannot map the generic type \"${type.getName()}\" to a known type`);\n        }\n        return factory(...mappedTypeParameters);\n    }\n}\nexports.TypeMapper = TypeMapper;\n//# sourceMappingURL=typeMapper.js.map"]},"metadata":{},"sourceType":"script"}